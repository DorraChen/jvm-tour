[TOC]

# 深入理解Java虚拟机第三版笔记

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

当Java虚拟机遇到一条字节码new指令时，

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用, 并且检查这个符号引用代表的类是否已被加载、解析和初始化过. 如果没有，那必须先执行相应的类加载过程.
2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存, 

**为对象分配内存空间的方式**

- 指针碰撞(Bump The Pointer);
- 空闲列表(Free List).

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定

**虚拟机创建对象时分配内存时修改指针存在线程不安全问题, 有两种解决方案:**

- 采用CAS配上失败重试的方式;
- 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)

### 2.3.2 对象的内存布局

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：

- 对象头（Header）
- 实例数据（Instance Data）
- 对齐填充（Padding）

1.对象头部分包含两类信息

- 第一部分是用于存储对象自身的运行时数据.
  - 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”.
- 第二部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例.
  - 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身.
  - 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小.

2.实例数据部分

- 实例数据部分是对象真正存储的有效信息
  - 在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来;
  - 这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响;

3.对齐填充

- 并不是必然存在的，它仅仅起着占位符的作用，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全.

### 2.3.3 对象的访问定位

主流的访问方式主要有两种:

- 使用句柄访问

  ![2.3.3-使用句柄访问.png](img/2.3.3-使用句柄访问.png)

  - 使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改;

- 直接指针访问

  ![2.3.3-使用直接指针访问.png](img/2.3.3-使用直接指针访问.png)

  - 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本.

## 2.4 OOM异常(OutOfMemoryError)

### 2.4.1 Java堆溢出

- 异常堆栈信息: `java.lang.OutOfMemoryError: Java heap space`
- 通过参数 `-XX：+HeapDumpOnOutOf-MemoryError` 可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析
- 解决方法:
  - 首先通过内存映像分析工具对Dump出来的堆转储快照进行分析, 应确认内存中导致OOM的对象是否是必
    要的, 也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory
    Overflow）;
  - 如果是内存泄漏, 通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们, 根据泄漏对象的类型信息以及它到GC Roots引用链的信息, 定位到这些对象创建的位置, 找出产生内存泄漏的代码的具体位置;
  - 如果不是内存泄漏, 内存中的对象确实都是必须存活的, 检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间; 再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗.

### 2.4.2 虚拟机栈和本地方法栈溢出

